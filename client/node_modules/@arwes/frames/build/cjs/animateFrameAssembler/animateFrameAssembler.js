"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.animateFrameAssembler = void 0;
const motion_1 = require("motion");
const animated_1 = require("@arwes/animated");
const animateFrameAssembler = (props) => {
    const { element, duration, isEntering = true } = props;
    const bgs = Array.from(element.querySelectorAll('[data-name=bg]'));
    const lines = Array.from(element.querySelectorAll('[data-name=line]'));
    const decos = Array.from(element.querySelectorAll('[data-name=deco]'));
    const elements = [...bgs, ...lines, ...decos];
    for (const line of lines) {
        const length = line.getTotalLength();
        line.style.opacity = '1';
        line.style.strokeDasharray = String(length);
        line.dataset.length = String(length);
    }
    const lineAnimations = lines.map((line) => {
        const length = Number(line.dataset.length);
        return [line, { strokeDashoffset: [length, 0] }, { at: 0, duration, easing: animated_1.easing.outSine }];
    });
    const animation = (0, motion_1.timeline)([
        [bgs, { opacity: [0, 1] }, { at: 0, duration: duration / 2, easing: animated_1.easing.outSine }],
        [
            decos,
            { opacity: [0, 1, 0.5, 1] },
            { at: duration / 2, duration: duration / 2, easing: animated_1.easing.outSine }
        ],
        ...lineAnimations
    ], {
        direction: isEntering ? 'normal' : 'reverse'
    });
    void animation.finished.then(() => {
        for (const element of elements) {
            element.style.opacity = isEntering ? '1' : '0';
        }
        for (const line of lines) {
            line.style.strokeDasharray = '';
            line.style.strokeDashoffset = '';
        }
    });
    return animation;
};
exports.animateFrameAssembler = animateFrameAssembler;
