"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFrame = void 0;
const renderFrameElements_js_1 = require("../internal/renderFrameElements.js");
const drawFrameElements_js_1 = require("../internal/drawFrameElements.js");
const transitionFrameElements_js_1 = require("../internal/transitionFrameElements.js");
const createFrame = (svg, settings) => {
    if (!(svg instanceof SVGSVGElement)) {
        throw new Error('ARWES createFrame requires a <svg> element.');
    }
    const { animator } = settings;
    let width = 0;
    let height = 0;
    let observer;
    const container = settings.container ?? document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const contexts = { ...settings.contexts };
    const animations = new Map();
    const resize = () => {
        width = Math.floor(svg.clientWidth);
        height = Math.floor(svg.clientHeight);
        if (svg.getAttribute('viewBox') !== `0 0 ${width} ${height}`) {
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        }
    };
    const render = () => {
        (0, renderFrameElements_js_1.renderFrameElements)(container, settings.elements, animator, animations);
    };
    const draw = () => {
        if (width <= 0 || height <= 0) {
            return;
        }
        (0, drawFrameElements_js_1.drawFrameElements)(container, width, height, settings.elements, contexts);
    };
    const transition = (context, state) => {
        contexts[context] = state;
        draw();
        (0, transitionFrameElements_js_1.transitionFrameElements)(container, contexts, animations, settings.elements);
    };
    const cancel = () => {
        observer.disconnect();
        animations.forEach((context) => context.forEach((animation) => animation.cancel()));
    };
    const remove = () => {
        cancel();
        Array.from(container.children).forEach((child) => child.remove());
    };
    container.dataset.frame = '';
    container.style.setProperty('vector-effect', 'non-scaling-stroke');
    resize();
    render();
    draw();
    if (contexts) {
        const contextNames = Object.keys(contexts);
        for (const contextName of contextNames) {
            transition(contextName, contexts[contextName]);
        }
    }
    if (!container.parentNode) {
        svg.appendChild(container);
    }
    let isFirstResize = true;
    observer = new ResizeObserver(() => {
        if (isFirstResize) {
            isFirstResize = false;
            return;
        }
        resize();
        draw();
    });
    observer.observe(svg);
    return Object.freeze({
        get contexts() {
            return Object.freeze({ ...contexts });
        },
        render: () => {
            resize();
            render();
            draw();
        },
        transition,
        cancel,
        remove
    });
};
exports.createFrame = createFrame;
