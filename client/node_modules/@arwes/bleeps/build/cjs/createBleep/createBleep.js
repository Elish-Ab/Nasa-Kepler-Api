"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBleep = void 0;
const createBleepSource_js_1 = require("./createBleepSource.js");
const createBleep = (props) => {
    const isBrowser = typeof window !== 'undefined';
    const isBrowserSafari = isBrowser &&
        window.navigator.userAgent.includes('Safari') &&
        !window.navigator.userAgent.includes('Chrome');
    const isBleepsAvailable = isBrowser && !!window.AudioContext;
    if (!isBleepsAvailable) {
        return null;
    }
    const { sources, preload = true, asyncLoad, loop, fetchHeaders, masterGain, maxPlaybackDelay = 0.25, muteOnWindowBlur } = props;
    let volume = props.volume ?? 1;
    let muted = !!props.muted;
    let isExternallyMuted = false;
    let isBufferLoading = false;
    let isBufferError = false;
    let isBufferPlaying = false;
    let playbackCallbackTime = 0;
    let asyncLoadCallbackId;
    let bleepSource = null;
    let buffer = null;
    let duration = 0;
    let fetchPromise;
    const context = props.context ?? new window.AudioContext();
    const gain = context.createGain();
    const callersAccount = new Set();
    const fetchAudioFile = (src, type, callback) => {
        try {
            void window
                .fetch(src, {
                method: 'GET',
                headers: fetchHeaders
            })
                .then((response) => {
                if (!response.ok) {
                    throw new Error('ARWES bleep source could not be fetched.');
                }
                return response;
            })
                .then((response) => response.arrayBuffer())
                .then((audioArrayBuffer) => context.decodeAudioData(audioArrayBuffer))
                .then((audioBuffer) => {
                buffer = audioBuffer;
                duration = buffer.duration;
            })
                .catch((err) => {
                isBufferError = true;
                console.error(`ARWES bleep with source URL "${src}" and type "${type}" could not be used:`, err);
            })
                .then(() => {
                isBufferLoading = false;
                callback();
            });
        }
        catch (err) {
            isBufferError = true;
            isBufferLoading = false;
            console.error(`ARWES bleep throws when fetched.`);
        }
    };
    function loadAudioBuffer() {
        if (buffer || isBufferLoading || isBufferError) {
            return;
        }
        if (!sources.length) {
            isBufferError = true;
            console.error('ARWES bleep must have at least one source with a valid audio file URL and type.');
            return;
        }
        const audioTest = new window.Audio();
        const source = sources.find((source) => {
            if (isBrowserSafari && source.type.includes('audio/webm')) {
                return false;
            }
            const support = audioTest.canPlayType(source.type || '');
            return support === 'probably' || support === 'maybe';
        });
        if (!source) {
            isBufferError = true;
            console.error(`ARWES bleep sources "${JSON.stringify(sources)}" are not supported on this navigator.`);
            return;
        }
        const { src, type } = source;
        isBufferLoading = true;
        fetchPromise = new Promise((resolve) => {
            if (asyncLoad) {
                asyncLoadCallbackId = window.setTimeout(() => {
                    fetchAudioFile(src, type, resolve);
                }, 0);
            }
            else {
                fetchAudioFile(src, type, resolve);
            }
        });
    }
    function onUserAllowAudio() {
        window.removeEventListener('click', onUserAllowAudio);
        if (context.state === 'suspended') {
            void context.resume();
        }
    }
    function onUserWindowFocus() {
        if (muteOnWindowBlur) {
            isExternallyMuted = false;
            update({});
        }
    }
    function onUserWindowBlur() {
        if (muteOnWindowBlur) {
            isExternallyMuted = true;
            update({});
        }
    }
    function play(caller) {
        const schedulePlay = () => {
            if (Date.now() <= playbackCallbackTime + maxPlaybackDelay * 1000) {
                play(caller);
            }
        };
        playbackCallbackTime = Date.now();
        if (isBufferError) {
            return;
        }
        if (isBufferLoading) {
            void fetchPromise.then(schedulePlay);
            return;
        }
        if (!buffer) {
            loadAudioBuffer();
            void fetchPromise.then(schedulePlay);
            return;
        }
        if (caller !== undefined) {
            callersAccount.add(caller);
        }
        if (loop && isBufferPlaying) {
            return;
        }
        if (context.state === 'suspended') {
            window.addEventListener('click', onUserAllowAudio);
            context
                .resume()
                .then(schedulePlay)
                .catch((err) => {
                const sourcesText = JSON.stringify(sources);
                console.error(`ARWES bleep audio context with sources "${sourcesText}" could not be resumed to be played:`, err);
            });
            return;
        }
        if (bleepSource) {
            bleepSource.stop();
        }
        bleepSource = (0, createBleepSource_js_1.createBleepSource)({
            context,
            buffer,
            gain,
            loop,
            onStop() {
                isBufferPlaying = false;
            }
        });
        isBufferPlaying = true;
        bleepSource.start();
    }
    function stop(caller) {
        if (!buffer) {
            return;
        }
        if (caller !== undefined) {
            callersAccount.delete(caller);
        }
        const canStop = loop ? !callersAccount.size : true;
        if (canStop) {
            if (bleepSource) {
                bleepSource.stop();
            }
            isBufferPlaying = false;
        }
    }
    function load() {
        loadAudioBuffer();
    }
    function unload() {
        if (bleepSource) {
            bleepSource.stop();
        }
        bleepSource = null;
        buffer = null;
        isBufferLoading = false;
        isBufferError = false;
        isBufferPlaying = false;
        window.clearTimeout(asyncLoadCallbackId);
        window.removeEventListener('click', onUserAllowAudio);
        window.removeEventListener('focus', onUserWindowFocus);
        window.removeEventListener('blur', onUserWindowBlur);
    }
    function update(newProps) {
        if (newProps.volume !== undefined) {
            volume = Math.max(0, Math.min(1, newProps.volume));
        }
        if (newProps.muted !== undefined) {
            muted = !!newProps.muted;
        }
        const newVolume = muted || isExternallyMuted ? 0 : volume;
        if (newVolume !== gain.gain.value) {
            gain.gain.value = newVolume;
        }
    }
    const bleep = {};
    const bleepAPI = {
        duration: {
            get: () => duration,
            enumerable: true
        },
        volume: {
            get: () => volume,
            set: (volume) => update({ volume }),
            enumerable: true
        },
        muted: {
            get: () => muted,
            set: (muted) => update({ muted }),
            enumerable: true
        },
        isPlaying: {
            get: () => isBufferPlaying,
            enumerable: true
        },
        isLoaded: {
            get: () => !!buffer,
            enumerable: true
        },
        play: {
            value: play,
            enumerable: true
        },
        stop: {
            value: stop,
            enumerable: true
        },
        load: {
            value: load,
            enumerable: true
        },
        unload: {
            value: unload,
            enumerable: true
        },
        update: {
            value: update,
            enumerable: true
        }
    };
    Object.defineProperties(bleep, bleepAPI);
    if (masterGain) {
        gain.connect(masterGain);
    }
    else {
        gain.connect(context.destination);
    }
    update({ volume });
    if (preload) {
        loadAudioBuffer();
    }
    if (muteOnWindowBlur) {
        window.addEventListener('focus', onUserWindowFocus);
        window.addEventListener('blur', onUserWindowBlur);
    }
    return bleep;
};
exports.createBleep = createBleep;
