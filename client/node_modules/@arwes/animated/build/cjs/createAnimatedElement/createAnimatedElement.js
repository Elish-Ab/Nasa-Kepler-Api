"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatedElement = void 0;
const motion_1 = require("motion");
const tools_1 = require("@arwes/tools");
const index_js_1 = require("../easing/index.js");
const index_js_2 = require("../applyAnimatedCSSProps/index.js");
const index_js_3 = require("../transitions/index.js");
const animatedPresets = {
    fade: index_js_3.fade,
    flicker: index_js_3.flicker,
    draw: index_js_3.draw
};
const createAnimatedElement = (props) => {
    const { element, animator } = props;
    const getSettings = () => ({
        hideOnExited: true,
        renderInitials: true,
        ...(0, tools_1.filterProps)(props.settingsRef.current)
    });
    const animations = new Set();
    const settingsInitial = getSettings();
    if (settingsInitial.renderInitials) {
        const { animated } = settingsInitial;
        const animatedListReceived = Array.isArray(animated) ? animated : [animated];
        const animatedList = animatedListReceived
            .map((item) => (typeof item === 'string' || Array.isArray(item) ? undefined : item))
            .filter(Boolean);
        const initialAttributes = animatedList
            .map((item) => (item ? item.initialAttributes : null))
            .reduce((total, item) => ({ ...total, ...item }), {});
        Object.keys(initialAttributes).forEach((attribute) => {
            element.setAttribute(attribute, initialAttributes[attribute]);
        });
        const dynamicStyles = animatedList
            .map((item) => (item ? item.initialStyle : null))
            .reduce((total, item) => ({ ...total, ...item }), {});
        (0, index_js_2.applyAnimatedCSSProps)(element, dynamicStyles);
    }
    const unsubscribe = animator.subscribe((node) => {
        const { animated, hideOnExited, hideOnEntered, onTransition } = getSettings();
        element.style.visibility =
            (hideOnExited && node.state === 'exited') || (hideOnEntered && node.state === 'entered')
                ? 'hidden'
                : '';
        const nodeSettings = node.settings;
        const nodeDuration = nodeSettings.duration;
        const transitionDuration = node.state === 'entering' || node.state === 'entered' ? nodeDuration.enter : nodeDuration.exit;
        const $ = (query) => Array.from(element.querySelectorAll(query));
        const animatedListReceived = Array.isArray(animated) ? animated : [animated];
        const animatedList = animatedListReceived.filter(Boolean);
        animatedList
            .filter(Boolean)
            .map((item) => {
            if (typeof item === 'string') {
                const preset = animatedPresets[item];
                if (!preset) {
                    throw new Error(`ARWES createAnimatedElement() unexpected animated preset "${item}".`);
                }
                return preset();
            }
            if (Array.isArray(item)) {
                return (0, index_js_3.transition)(...item);
            }
            return item;
        })
            .map((settingsItem) => (settingsItem ? settingsItem.transitions?.[node.state] : null))
            .filter(Boolean)
            .forEach((transition) => {
            if (typeof transition === 'function') {
                const animation = transition({
                    element,
                    $,
                    duration: transitionDuration,
                    nodeDuration,
                    easing: index_js_1.easing,
                    animate: motion_1.animate,
                    timeline: motion_1.timeline,
                    stagger: motion_1.stagger,
                    spring: motion_1.spring,
                    glide: motion_1.glide
                });
                if (animation) {
                    animations.add(animation);
                    if (animation.then) {
                        void animation.then(() => {
                            animations.delete(animation);
                        });
                    }
                    else if (animation.finished) {
                        void animation.finished.then(() => {
                            animations.delete(animation);
                        });
                    }
                }
            }
            else if (transition) {
                const { duration: durationInitial, delay, easing: ease, repeat, direction, options, ...definition } = transition;
                const duration = durationInitial || transitionDuration;
                if (duration <= 0) {
                    throw new Error('ARWES createAnimatedElement() animation duration must be greater than 0.');
                }
                try {
                    const animation = (0, motion_1.animate)(element, definition, {
                        duration,
                        delay,
                        easing: typeof ease === 'string' ? (index_js_1.easing[ease] ?? ease) : ease,
                        repeat,
                        direction,
                        ...options
                    });
                    animations.add(animation);
                    void animation.finished.then(() => {
                        animations.delete(animation);
                    });
                }
                catch (err) {
                    throw new Error(`ARWES createAnimatedElement() animation error:\n${String(err)}`);
                }
            }
        });
        onTransition?.(element, node);
    });
    const cancel = () => {
        unsubscribe();
        animations.forEach((animation) => animation.cancel());
        animations.clear();
    };
    return Object.freeze({ settingsRef: props.settingsRef, cancel });
};
exports.createAnimatedElement = createAnimatedElement;
