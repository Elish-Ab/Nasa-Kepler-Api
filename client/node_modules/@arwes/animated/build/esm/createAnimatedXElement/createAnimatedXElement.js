import { animate, timeline, stagger, spring, glide } from 'motion';
import { filterProps } from '@arwes/tools';
import { applyAnimatedCSSProps } from '../applyAnimatedCSSProps/index.js';
import { easing } from '../easing/index.js';
const createAnimatedXElement = (props) => {
    const { element } = props;
    const getSettings = () => ({
        hideOnStates: [],
        renderInitials: true,
        ...filterProps(props.settingsRef.current)
    });
    let stateLastExecuted = props.settingsRef.current.state;
    const animations = new Set();
    const settingsInitial = getSettings();
    if (settingsInitial.renderInitials) {
        const { animated } = settingsInitial;
        const animatedListReceived = Array.isArray(animated) ? animated : [animated];
        const animatedList = animatedListReceived.filter(Boolean);
        const initialAttributes = animatedList
            .map((item) => item?.initialAttributes)
            .reduce((total, item) => ({ ...total, ...item }), {});
        Object.keys(initialAttributes).forEach((attribute) => {
            element.setAttribute(attribute, initialAttributes[attribute]);
        });
        const dynamicStyles = animatedList
            .map((item) => item?.initialStyle)
            .reduce((total, item) => ({ ...total, ...item }), {});
        applyAnimatedCSSProps(element, dynamicStyles);
    }
    const runAnimations = () => {
        const { state, animated, hideOnStates } = getSettings();
        stateLastExecuted = state;
        const animatedListReceived = Array.isArray(animated) ? animated : [animated];
        const animatedList = animatedListReceived.filter(Boolean);
        element.style.visibility = hideOnStates?.includes(state) ? 'hidden' : '';
        const $ = (query) => Array.from(element.querySelectorAll(query));
        animatedList
            .map((settingsItem) => settingsItem.transitions?.[state])
            .filter(Boolean)
            .forEach((transition) => {
            if (typeof transition === 'function') {
                const animation = transition({
                    element,
                    $,
                    easing,
                    animate,
                    timeline,
                    stagger,
                    spring,
                    glide
                });
                if (animation) {
                    animations.add(animation);
                    if (animation.then) {
                        void animation.then(() => {
                            animations.delete(animation);
                        });
                    }
                    else if (animation.finished) {
                        void animation.finished.then(() => {
                            animations.delete(animation);
                        });
                    }
                }
            }
            else {
                const { duration, delay, easing: ease, repeat, direction, options, ...definition } = transition;
                if (Number.isFinite(duration) && duration <= 0) {
                    throw new Error('ARWES createAnimatedXElement() animation duration must be greater than 0.');
                }
                try {
                    const animation = animate(element, definition, {
                        duration,
                        delay,
                        easing: typeof ease === 'string' ? easing[ease] : ease,
                        repeat,
                        direction,
                        ...options
                    });
                    animations.add(animation);
                    void animation.finished.then(() => {
                        animations.delete(animation);
                    });
                }
                catch (err) {
                    throw new Error(`ARWES createAnimatedXElement() animation error:\n${String(err)}`);
                }
            }
        });
    };
    runAnimations();
    const refresh = () => {
        if (stateLastExecuted !== props.settingsRef.current.state) {
            runAnimations();
        }
    };
    const cancel = () => {
        animations.forEach((animation) => animation.cancel());
        animations.clear();
    };
    return Object.freeze({ refresh, cancel });
};
export { createAnimatedXElement };
