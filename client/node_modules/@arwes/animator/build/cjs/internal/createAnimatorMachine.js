"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatorMachine = void 0;
const tools_1 = require("@arwes/tools");
const constants_js_1 = require("../constants.js");
const createAnimatorManager_js_1 = require("./createAnimatorManager.js");
const createAnimatorMachine = (node, initialState) => {
    let state = initialState;
    const statesMap = {
        [constants_js_1.ANIMATOR_STATES.exited]: {
            onActions: {
                [constants_js_1.ANIMATOR_ACTIONS.enter]: constants_js_1.ANIMATOR_STATES.entering,
                [constants_js_1.ANIMATOR_ACTIONS.setup]: () => {
                    const settings = node._getUserSettings();
                    if (node._parent) {
                        const parentSettings = node._parent._getUserSettings();
                        const { condition } = settings;
                        switch (node._parent.state) {
                            case constants_js_1.ANIMATOR_STATES.entering: {
                                const allowed = typeof condition === 'function'
                                    ? condition(node)
                                    : typeof condition === 'boolean'
                                        ? condition
                                        : true;
                                if ((parentSettings.combine || settings.merge) && allowed) {
                                    node._parent._manager.enterChildren([node]);
                                }
                                break;
                            }
                            case constants_js_1.ANIMATOR_STATES.entered: {
                                const allowed = typeof condition === 'function'
                                    ? condition(node)
                                    : typeof condition === 'boolean'
                                        ? condition
                                        : true;
                                if (allowed) {
                                    node._parent._manager.enterChildren([node]);
                                }
                                break;
                            }
                        }
                    }
                    else {
                        const isActive = settings.active === undefined || settings.active;
                        if (isActive) {
                            if (settings.duration.delay > 0) {
                                return {
                                    duration: settings.duration.delay,
                                    state: constants_js_1.ANIMATOR_STATES.entering
                                };
                            }
                            return constants_js_1.ANIMATOR_STATES.entering;
                        }
                    }
                }
            }
        },
        [constants_js_1.ANIMATOR_STATES.entering]: {
            onEntry: {
                execute: () => {
                    const settings = node._getUserSettings();
                    const children = Array.from(node._children).filter((child) => {
                        const childSettings = child._getUserSettings();
                        if (settings.combine || childSettings.merge) {
                            const { condition } = childSettings;
                            const childAllowedToEnter = typeof condition === 'function'
                                ? condition(child)
                                : typeof condition === 'boolean'
                                    ? condition
                                    : true;
                            return childAllowedToEnter;
                        }
                        return false;
                    });
                    node._manager.enterChildren(children);
                },
                schedule: () => ({
                    duration: node.settings.duration.enter,
                    action: constants_js_1.ANIMATOR_ACTIONS.enterEnd
                })
            },
            onActions: {
                [constants_js_1.ANIMATOR_ACTIONS.enterEnd]: constants_js_1.ANIMATOR_STATES.entered,
                [constants_js_1.ANIMATOR_ACTIONS.exit]: constants_js_1.ANIMATOR_STATES.exiting
            }
        },
        [constants_js_1.ANIMATOR_STATES.entered]: {
            onEntry: {
                execute: () => {
                    const settings = node._getUserSettings();
                    if (settings.combine) {
                        return;
                    }
                    const children = Array.from(node._children).filter((child) => {
                        const childSettings = child._getUserSettings();
                        const { condition } = childSettings;
                        const allowed = typeof condition === 'function'
                            ? condition(child)
                            : typeof condition === 'boolean'
                                ? condition
                                : true;
                        return !childSettings.merge && allowed;
                    });
                    node._manager.enterChildren(children);
                }
            },
            onActions: {
                [constants_js_1.ANIMATOR_ACTIONS.exit]: constants_js_1.ANIMATOR_STATES.exiting
            }
        },
        [constants_js_1.ANIMATOR_STATES.exiting]: {
            onEntry: {
                execute: () => {
                    node._manager.exitChildren(Array.from(node._children));
                },
                schedule: () => ({
                    duration: node.settings.duration.exit,
                    action: constants_js_1.ANIMATOR_ACTIONS.exitEnd
                })
            },
            onActions: {
                [constants_js_1.ANIMATOR_ACTIONS.exitEnd]: constants_js_1.ANIMATOR_STATES.exited,
                [constants_js_1.ANIMATOR_ACTIONS.enter]: constants_js_1.ANIMATOR_STATES.entering
            }
        },
        '*': {
            onActions: {
                [constants_js_1.ANIMATOR_ACTIONS.update]: () => {
                    const settings = node._getUserSettings();
                    if (settings.manager !== node._manager.name) {
                        node._manager.destroy?.();
                        node._manager = (0, createAnimatorManager_js_1.createAnimatorManager)(node, settings.manager);
                    }
                    if (!node._parent) {
                        const isActive = settings.active === true || settings.active === undefined;
                        if ((state === constants_js_1.ANIMATOR_STATES.exited || state === constants_js_1.ANIMATOR_STATES.exiting) && isActive) {
                            if (settings.duration.delay > 0) {
                                return {
                                    duration: settings.duration.delay,
                                    state: constants_js_1.ANIMATOR_STATES.entering
                                };
                            }
                            return constants_js_1.ANIMATOR_STATES.entering;
                        }
                        else if ((state === constants_js_1.ANIMATOR_STATES.entered || state === constants_js_1.ANIMATOR_STATES.entering) && !isActive) {
                            return constants_js_1.ANIMATOR_STATES.exiting;
                        }
                    }
                },
                [constants_js_1.ANIMATOR_ACTIONS.refresh]: () => {
                    const settings = node._getUserSettings();
                    const childrenWithSettings = Array.from(node._children).map((child) => ({
                        node: child,
                        settings: child._getUserSettings()
                    }));
                    if (node.state === constants_js_1.ANIMATOR_STATES.entering || node.state === constants_js_1.ANIMATOR_STATES.entered) {
                        const childrenInEnterToExit = childrenWithSettings
                            .filter((child) => child.node.state === constants_js_1.ANIMATOR_STATES.entering || child.node.state === constants_js_1.ANIMATOR_STATES.entered)
                            .filter((child) => {
                            if (node.state === constants_js_1.ANIMATOR_STATES.entering) {
                                return settings.combine || child.settings.merge;
                            }
                            return true;
                        })
                            .filter((child) => {
                            const { condition } = child.settings;
                            const allowed = typeof condition === 'function'
                                ? condition(child.node)
                                : typeof condition === 'boolean'
                                    ? condition
                                    : true;
                            return !allowed;
                        })
                            .map((child) => child.node);
                        const childrenInExitToEnter = childrenWithSettings
                            .filter((child) => child.node.state === constants_js_1.ANIMATOR_STATES.exiting || child.node.state === constants_js_1.ANIMATOR_STATES.exited)
                            .filter((child) => {
                            const { condition } = child.settings;
                            const allowed = typeof condition === 'function'
                                ? condition(child.node)
                                : typeof condition === 'boolean'
                                    ? condition
                                    : true;
                            return allowed;
                        })
                            .map((child) => child.node);
                        node._manager.exitChildren(childrenInEnterToExit);
                        node._manager.enterChildren(childrenInExitToEnter);
                    }
                }
            }
        }
    };
    const transition = (newState) => {
        if (!newState || state === newState) {
            return;
        }
        state = newState;
        const { onEntry } = statesMap[state] || {};
        const { onTransition } = node.control.getSettings();
        node._scheduler.stopAll();
        if (onEntry?.execute) {
            onEntry.execute();
        }
        if (onEntry?.schedule) {
            const task = onEntry.schedule();
            node._scheduler.start(task.duration, () => send(task.action));
        }
        onTransition?.(node);
        for (const subscriber of node._subscribers) {
            subscriber(node);
        }
    };
    const processAction = (procedure) => {
        if (procedure === undefined) {
            return;
        }
        if (typeof procedure === 'string') {
            transition(procedure);
        }
        else {
            const newState = procedure();
            if (typeof newState === 'object' && newState !== null) {
                node._scheduler.start(newState.duration, () => transition(newState.state));
            }
            else if (newState) {
                transition(newState);
            }
        }
    };
    const getState = () => state;
    const send = (action) => {
        if (!(0, tools_1.isBrowser)()) {
            return;
        }
        processAction(statesMap[state]?.onActions?.[action]);
        processAction(statesMap['*']?.onActions?.[action]);
    };
    const machine = Object.freeze({ getState, send });
    return machine;
};
exports.createAnimatorMachine = createAnimatorMachine;
