{"ast":null,"code":"import { randomizeList } from '@arwes/tools';\nimport { easing, createAnimation } from '@arwes/animated';\nconst defaultProps = {\n  lineWidth: 1,\n  lineColor: '#777',\n  distance: 30,\n  sets: 5\n};\nconst random = (min, max) => (max - min) * Math.random();\nconst minmaxOverflow01 = value => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\nconst createLinesSet = config => {\n  const {\n    distance,\n    positionsLength,\n    margin,\n    size\n  } = config;\n  const linesLength = Math.floor(random(0.1, 0.5) * positionsLength);\n  const positions = Array(positionsLength).fill(0).map((_, i) => i);\n  const positionsRandom = randomizeList(positions);\n  const positionsSelected = positionsRandom.slice(0, linesLength);\n  return positionsSelected.map(position => {\n    const axis1 = margin / 2 + position * distance;\n    const axis2Initial = Math.random() * (size / 2);\n    const length = Math.floor(random(0.1, 0.5) * size);\n    return {\n      axis1,\n      axis2Initial,\n      length\n    };\n  });\n};\nconst createBackgroundMovingLines = props => {\n  const {\n    canvas,\n    animator\n  } = props;\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return {\n      cancel: () => {}\n    };\n  }\n  let resizeObserver;\n  let transitionControl;\n  let runningControl;\n  let unsubscribe;\n  let linesSets = [];\n  const getSettings = () => ({\n    ...defaultProps,\n    ...props.settingsRef.current\n  });\n  const resize = () => {\n    const dpr = Math.min(window.devicePixelRatio || 2, 2);\n    const {\n      width,\n      height\n    } = canvas.getBoundingClientRect();\n    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n    }\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.scale(dpr, dpr);\n  };\n  const draw = intervalProgress => {\n    const {\n      lineWidth,\n      lineColor,\n      distance,\n      sets: linesSetsLength\n    } = getSettings();\n    const {\n      width,\n      height\n    } = canvas;\n    const isResized = canvas.width !== width || canvas.height !== height;\n    const axis1Size = width;\n    const axis2Size = height;\n    const positionsLength = 1 + Math.floor(axis1Size / distance);\n    const margin = axis1Size % distance;\n    ctx.clearRect(0, 0, width, height);\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = lineColor;\n    ctx.shadowBlur = lineWidth;\n    ctx.shadowOffsetX = 0;\n    ctx.shadowOffsetY = 0;\n    ctx.shadowColor = lineColor;\n    if (linesSets.length === 0 || isResized) {\n      linesSets = Array(linesSetsLength).fill(null).map(() => createLinesSet({\n        positionsLength,\n        margin,\n        distance,\n        size: axis2Size\n      }));\n    }\n    linesSets.forEach((linesSet, linesSetIndex) => {\n      const linesSetProgressOffset = 1 / linesSetsLength * linesSetIndex;\n      const progress = minmaxOverflow01(intervalProgress + linesSetProgressOffset);\n      const progressEase = easing.inOutCubic(progress);\n      linesSet.forEach(line => {\n        const {\n          axis1,\n          axis2Initial,\n          length\n        } = line;\n        const axis2Move = axis2Size * 2 * progressEase - axis2Size;\n        ctx.beginPath();\n        ctx.moveTo(axis1, axis2Size - (axis2Initial + axis2Move));\n        ctx.lineTo(axis1, axis2Size - (axis2Initial + length + axis2Move));\n        ctx.stroke();\n        ctx.closePath();\n      });\n    });\n  };\n  const run = () => {\n    if (!animator) {\n      return;\n    }\n    const {\n      duration: {\n        interval = 10\n      }\n    } = animator.settings;\n    runningControl?.cancel();\n    runningControl = createAnimation({\n      duration: interval,\n      easing: 'linear',\n      repeat: Infinity,\n      onUpdate: draw\n    });\n  };\n  const setup = () => {\n    if (typeof window !== 'undefined' && !resizeObserver) {\n      resizeObserver = new window.ResizeObserver(() => {\n        resize();\n        if (!animator) {\n          draw(1);\n        }\n      });\n      resizeObserver.observe(canvas);\n      resize();\n    }\n  };\n  const stop = () => {\n    resizeObserver?.disconnect();\n    resizeObserver = undefined;\n    transitionControl?.cancel();\n    transitionControl = undefined;\n    runningControl?.cancel();\n    runningControl = undefined;\n  };\n  const start = () => {\n    if (!animator) {\n      setup();\n      draw(1);\n      canvas.style.opacity = '1';\n      return;\n    }\n    unsubscribe = animator.subscribe(node => {\n      switch (node.state) {\n        case 'entering':\n          {\n            setup();\n            if (runningControl === undefined) {\n              run();\n            }\n            transitionControl = createAnimation({\n              duration: node.settings.duration.enter,\n              onUpdate(progress) {\n                canvas.style.opacity = String(progress);\n              }\n            });\n            break;\n          }\n        case 'entered':\n          {\n            setup();\n            if (runningControl === undefined) {\n              run();\n            }\n            canvas.style.opacity = '1';\n            break;\n          }\n        case 'exiting':\n          {\n            transitionControl = createAnimation({\n              duration: node.settings.duration.exit,\n              onUpdate(progress) {\n                canvas.style.opacity = String(1 - progress);\n              }\n            });\n            break;\n          }\n        case 'exited':\n          {\n            stop();\n            canvas.style.opacity = '0';\n            break;\n          }\n      }\n    });\n  };\n  const cancel = () => {\n    unsubscribe?.();\n    stop();\n    canvas.style.opacity = '0';\n  };\n  start();\n  return Object.freeze({\n    cancel\n  });\n};\nexport { createBackgroundMovingLines };","map":{"version":3,"names":["randomizeList","easing","createAnimation","defaultProps","lineWidth","lineColor","distance","sets","random","min","max","Math","minmaxOverflow01","value","createLinesSet","config","positionsLength","margin","size","linesLength","floor","positions","Array","fill","map","_","i","positionsRandom","positionsSelected","slice","position","axis1","axis2Initial","length","createBackgroundMovingLines","props","canvas","animator","ctx","getContext","cancel","resizeObserver","transitionControl","runningControl","unsubscribe","linesSets","getSettings","settingsRef","current","resize","dpr","window","devicePixelRatio","width","height","getBoundingClientRect","setTransform","scale","draw","intervalProgress","linesSetsLength","isResized","axis1Size","axis2Size","clearRect","strokeStyle","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","forEach","linesSet","linesSetIndex","linesSetProgressOffset","progress","progressEase","inOutCubic","line","axis2Move","beginPath","moveTo","lineTo","stroke","closePath","run","duration","interval","settings","repeat","Infinity","onUpdate","setup","ResizeObserver","observe","stop","disconnect","undefined","start","style","opacity","subscribe","node","state","enter","String","exit","Object","freeze"],"sources":["/home/elisha-a/Nasa/client/node_modules/@arwes/bgs/build/esm/createBackgroundMovingLines/createBackgroundMovingLines.js"],"sourcesContent":["import { randomizeList } from '@arwes/tools';\nimport { easing, createAnimation } from '@arwes/animated';\nconst defaultProps = {\n    lineWidth: 1,\n    lineColor: '#777',\n    distance: 30,\n    sets: 5\n};\nconst random = (min, max) => (max - min) * Math.random();\nconst minmaxOverflow01 = (value) => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\nconst createLinesSet = (config) => {\n    const { distance, positionsLength, margin, size } = config;\n    const linesLength = Math.floor(random(0.1, 0.5) * positionsLength);\n    const positions = Array(positionsLength)\n        .fill(0)\n        .map((_, i) => i);\n    const positionsRandom = randomizeList(positions);\n    const positionsSelected = positionsRandom.slice(0, linesLength);\n    return positionsSelected.map((position) => {\n        const axis1 = margin / 2 + position * distance;\n        const axis2Initial = Math.random() * (size / 2);\n        const length = Math.floor(random(0.1, 0.5) * size);\n        return { axis1, axis2Initial, length };\n    });\n};\nconst createBackgroundMovingLines = (props) => {\n    const { canvas, animator } = props;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        return { cancel: () => { } };\n    }\n    let resizeObserver;\n    let transitionControl;\n    let runningControl;\n    let unsubscribe;\n    let linesSets = [];\n    const getSettings = () => ({\n        ...defaultProps,\n        ...props.settingsRef.current\n    });\n    const resize = () => {\n        const dpr = Math.min(window.devicePixelRatio || 2, 2);\n        const { width, height } = canvas.getBoundingClientRect();\n        if (canvas.width !== width * dpr || canvas.height !== height * dpr) {\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n        }\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.scale(dpr, dpr);\n    };\n    const draw = (intervalProgress) => {\n        const { lineWidth, lineColor, distance, sets: linesSetsLength } = getSettings();\n        const { width, height } = canvas;\n        const isResized = canvas.width !== width || canvas.height !== height;\n        const axis1Size = width;\n        const axis2Size = height;\n        const positionsLength = 1 + Math.floor(axis1Size / distance);\n        const margin = axis1Size % distance;\n        ctx.clearRect(0, 0, width, height);\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = lineColor;\n        ctx.shadowBlur = lineWidth;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.shadowColor = lineColor;\n        if (linesSets.length === 0 || isResized) {\n            linesSets = Array(linesSetsLength)\n                .fill(null)\n                .map(() => createLinesSet({ positionsLength, margin, distance, size: axis2Size }));\n        }\n        linesSets.forEach((linesSet, linesSetIndex) => {\n            const linesSetProgressOffset = (1 / linesSetsLength) * linesSetIndex;\n            const progress = minmaxOverflow01(intervalProgress + linesSetProgressOffset);\n            const progressEase = easing.inOutCubic(progress);\n            linesSet.forEach((line) => {\n                const { axis1, axis2Initial, length } = line;\n                const axis2Move = axis2Size * 2 * progressEase - axis2Size;\n                ctx.beginPath();\n                ctx.moveTo(axis1, axis2Size - (axis2Initial + axis2Move));\n                ctx.lineTo(axis1, axis2Size - (axis2Initial + length + axis2Move));\n                ctx.stroke();\n                ctx.closePath();\n            });\n        });\n    };\n    const run = () => {\n        if (!animator) {\n            return;\n        }\n        const { duration: { interval = 10 } } = animator.settings;\n        runningControl?.cancel();\n        runningControl = createAnimation({\n            duration: interval,\n            easing: 'linear',\n            repeat: Infinity,\n            onUpdate: draw\n        });\n    };\n    const setup = () => {\n        if (typeof window !== 'undefined' && !resizeObserver) {\n            resizeObserver = new window.ResizeObserver(() => {\n                resize();\n                if (!animator) {\n                    draw(1);\n                }\n            });\n            resizeObserver.observe(canvas);\n            resize();\n        }\n    };\n    const stop = () => {\n        resizeObserver?.disconnect();\n        resizeObserver = undefined;\n        transitionControl?.cancel();\n        transitionControl = undefined;\n        runningControl?.cancel();\n        runningControl = undefined;\n    };\n    const start = () => {\n        if (!animator) {\n            setup();\n            draw(1);\n            canvas.style.opacity = '1';\n            return;\n        }\n        unsubscribe = animator.subscribe((node) => {\n            switch (node.state) {\n                case 'entering': {\n                    setup();\n                    if (runningControl === undefined) {\n                        run();\n                    }\n                    transitionControl = createAnimation({\n                        duration: node.settings.duration.enter,\n                        onUpdate(progress) {\n                            canvas.style.opacity = String(progress);\n                        }\n                    });\n                    break;\n                }\n                case 'entered': {\n                    setup();\n                    if (runningControl === undefined) {\n                        run();\n                    }\n                    canvas.style.opacity = '1';\n                    break;\n                }\n                case 'exiting': {\n                    transitionControl = createAnimation({\n                        duration: node.settings.duration.exit,\n                        onUpdate(progress) {\n                            canvas.style.opacity = String(1 - progress);\n                        }\n                    });\n                    break;\n                }\n                case 'exited': {\n                    stop();\n                    canvas.style.opacity = '0';\n                    break;\n                }\n            }\n        });\n    };\n    const cancel = () => {\n        unsubscribe?.();\n        stop();\n        canvas.style.opacity = '0';\n    };\n    start();\n    return Object.freeze({ cancel });\n};\nexport { createBackgroundMovingLines };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}